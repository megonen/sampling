<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DA Sampling Calculator</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7.23.2/babel.min.js"></script>
  <script src="https://unpkg.com/recharts@2.5.0/umd/Recharts.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { background: #0d1117; color: #e6edf3; font-family: 'Segoe UI', system-ui, sans-serif; }
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button { opacity: 1; }
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: #0d1117; }
    ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 3px; }
    #root { min-height: 100vh; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const {
      useState, useMemo, useCallback
    } = React;

    const {
      LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip,
      Legend, ReferenceLine, ReferenceArea, ResponsiveContainer,
      ComposedChart, Scatter
    } = Recharts;

    // ─── Math Utilities ──────────────────────────────────────────────────────────

    function makeLogFact(maxN) {
      const lf = new Float64Array(maxN + 2);
      lf[0] = 0;
      for (let i = 1; i <= maxN + 1; i++) lf[i] = lf[i - 1] + Math.log(i);
      return lf;
    }
    function logBinom(n, k, lf) {
      if (k < 0 || k > n || n < 0) return -Infinity;
      if (k === 0 || k === n) return 0;
      return lf[n] - lf[k] - lf[n - k];
    }
    function hyperPMF(N, K, S, k, lf) {
      const lo = Math.max(0, S - (N - K));
      const hi = Math.min(S, K);
      if (k < lo || k > hi) return 0;
      const logp = logBinom(K, k, lf) + logBinom(N - K, S - k, lf) - logBinom(N, S, lf);
      return Math.exp(logp);
    }
    function pDetect(N, NA, S, tau, lf) {
      let p = 0;
      const hi = Math.min(S, NA);
      for (let g = Math.max(tau, 0); g <= hi; g++) p += hyperPMF(N, NA, S, g, lf);
      return Math.min(1, Math.max(0, p));
    }
    function log10Alpha(N, K, S, tau, lf) {
      const hi = Math.min(S, K);
      if (tau > hi) return -Infinity;
      let maxLogP = -Infinity;
      const logPs = [];
      for (let g = tau; g <= hi; g++) {
        const lp = logBinom(K, g, lf) + logBinom(N - K, S - g, lf) - logBinom(N, S, lf);
        logPs.push(lp);
        if (lp > maxLogP) maxLogP = lp;
      }
      if (!isFinite(maxLogP)) return -Infinity;
      let sum = 0;
      for (const lp of logPs) sum += Math.exp(lp - maxLogP);
      return (maxLogP + Math.log(sum)) * Math.LOG10E;
    }
    function log10Beta(N, K, Delta, S, tau, lf) {
      const NA = K + Delta;
      if (NA > N || tau <= 0) return -Infinity;
      const hi = Math.min(tau - 1, Math.min(S, NA));
      const lo = Math.max(0, S - (N - NA));
      let maxLogP = -Infinity;
      const logPs = [];
      for (let g = lo; g <= hi; g++) {
        const lp = logBinom(NA, g, lf) + logBinom(N - NA, S - g, lf) - logBinom(N, S, lf);
        logPs.push(lp);
        if (lp > maxLogP) maxLogP = lp;
      }
      if (!isFinite(maxLogP)) return -Infinity;
      let sum = 0;
      for (const lp of logPs) sum += Math.exp(lp - maxLogP);
      return (maxLogP + Math.log(sum)) * Math.LOG10E;
    }
    function KL(q, p) {
      if (q <= 0 || q >= 1 || p <= 0 || p >= 1) return Infinity;
      return q * Math.log(q / p) + (1 - q) * Math.log((1 - q) / (1 - p));
    }
    // ── Block-builder helpers ────────────────────────────────────────────────
    // Returns z-quantile of standard normal (lookup table)
    function zQuantile(q){
      if(q>=0.9999)return 3.7190;
      if(q>=0.999) return 3.0902;
      if(q>=0.99)  return 2.3263;
      if(q>=0.95)  return 1.6449;
      return 1.2816; // 0.90
    }
    // Normal approximation: τ_{NB,q} ≈ (NB + z_q·√NB) / p
    // Valid for NB ≥ ~10; becomes exact as NB→∞
    function negBinApprox(NB, p, zq){
      if(p<=0||p>=1||NB<1) return null;
      return (NB + zq*Math.sqrt(NB)) / p;
    }
    // Exact negative-binomial q-quantile via PMF recurrence.
    // P(τ_NB=t+1) = P(τ_NB=t) · (t/(t-NB)) · (1-p)
    // Feasible only when NB·|log₁₀ p| ≲ 300 to avoid underflow.
    function negBinExact(NB, p, q){
      if(p<=0||p>=1||NB<1) return null;
      if(-NB*Math.log10(p)>300) return null; // p^NB underflows
      const MAX=1000000;
      let pmf=Math.pow(p,NB), cdf=pmf;
      if(!isFinite(pmf)||pmf===0) return null;
      if(cdf>=q) return NB;
      for(let t=NB+1; t<=NB+MAX; t++){
        pmf *= (t-1)/(t-NB)*(1-p);
        if(!isFinite(pmf)||pmf<1e-300) break;
        cdf += pmf;
        if(cdf>=q) return t;
      }
      return null; // didn't converge — use approx
    }
    function findOptimalTau(N, K, Delta, S, lf) {
      let bestTau = 0, bestMax = Infinity;
      for (let t = 0; t <= S; t++) {
        const a = pDetect(N, K, S, t, lf);
        const NA2 = K + Delta;
        let b = 0;
        if (NA2 <= N) for (let g = 0; g < t; g++) b += hyperPMF(N, NA2, S, g, lf);
        const mx = Math.max(a, Math.min(1, b));
        if (mx < bestMax) { bestMax = mx; bestTau = t; }
      }
      return { tau: bestTau, maxErr: bestMax };
    }
    // N_A(1/2): minimum N_A such that P(n_A >= tau | N_A) >= 0.5
    // Matches Python's find_U_half — binary search exploiting monotonicity in N_A
    function findUHalf(N, S, tau, lf) {
      if (pDetect(N, N, S, tau, lf) < 0.5) return null;
      if (pDetect(N, 0, S, tau, lf) >= 0.5) return 0;
      let lo = 0, hi = N;
      while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (pDetect(N, mid, S, tau, lf) >= 0.5) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }

    function sampleHypergeometric(N, NA, S) {
      let pop = NA, rem = N, count = 0;
      for (let i = 0; i < S; i++) {
        if (Math.random() < pop / rem) { count++; pop--; }
        rem--;
      }
      return count;
    }

    // Simulate negative binomial hitting time — returns empirical q-quantile
    // Uses Int32Array for speed; caps draws to avoid infinite loops for small p
    function simNegBin(NB, p, trials, q) {
      if (p <= 0 || p >= 1 || NB < 1) return null;
      const avgDraws = NB / p;
      if (avgDraws > 2e6) return null; // infeasible in browser
      const maxDraws = Math.min(Math.ceil(20 * avgDraws), 5000000);
      const samples = new Int32Array(trials);
      for (let t = 0; t < trials; t++) {
        let successes = 0, draws = 0;
        while (successes < NB && draws < maxDraws) {
          if (Math.random() < p) successes++;
          draws++;
        }
        samples[t] = draws;
      }
      samples.sort();
      return samples[Math.min(Math.ceil(q * trials) - 1, trials - 1)];
    }

    function simMajority(n, p, trials) {
      if (p <= 0 || !isFinite(p)) return 0;
      if (p >= 1) return 1;
      const half = Math.ceil(n / 2);
      let count = 0;
      for (let t = 0; t < trials; t++) {
        let s = 0;
        for (let i = 0; i < n; i++) if (Math.random() < p) s++;
        if (s >= half) count++;
      }
      return count / trials;
    }

    // ─── Design tokens ───────────────────────────────────────────────────────────
    const C = {
      bg:"#0d1117", panel:"#161b22", panel2:"#1c2128", border:"#30363d",
      blue:"#58a6ff", red:"#f85149", green:"#3fb950", yellow:"#d29922",
      purple:"#bc8cff", orange:"#e07b39", teal:"#39d0c8",
      text:"#e6edf3", muted:"#8b949e",
    };
    const MULTI_DELTA_COLORS = [C.blue, C.red, C.green, C.yellow, C.purple];
    const MULTI_S_COLORS     = [C.blue, C.red, C.green, C.yellow];
    // Block-builder constants (matching document figures)
    const BUILDER_NB   = [1,2,4,8,16,32,64,128,256,512,1024];
    const EPS_VALS     = [0.1, 0.01, 0.001, 0.0001];
    const EPS_LBLS     = ["10⁻¹","10⁻²","10⁻³","10⁻⁴"];
    const EPS_COLS     = [C.yellow, C.green, C.blue, C.purple];
    const PGREY_VALS   = [0.2, 0.3, 0.5, 0.7];
    const PGREY_COLS   = [C.blue, C.green, C.yellow, C.red];

    // ─── Shared UI ───────────────────────────────────────────────────────────────
    function ParamInput({ label, value, onChange, step, min, max }) {
      return (
        <div style={{display:"flex",flexDirection:"column",gap:3}}>
          <label style={{fontSize:11,color:C.muted,fontFamily:"monospace",letterSpacing:"0.04em"}}>{label}</label>
          <input type="number" value={value} step={step||1} min={min} max={max}
            onChange={e=>onChange(parseFloat(e.target.value))}
            style={{background:C.bg,border:`1px solid ${C.border}`,borderRadius:5,
              color:C.text,fontFamily:"monospace",fontSize:12,padding:"4px 8px",width:108,outline:"none"}} />
        </div>
      );
    }
    function StatCard({ label, value, color }) {
      return (
        <div style={{background:C.bg,border:`1px solid ${color||C.border}`,borderRadius:7,padding:"8px 13px",minWidth:150}}>
          <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:3}}>{label}</div>
          <div style={{fontSize:13,color:color||C.text,fontFamily:"monospace",fontWeight:"bold"}}>{value}</div>
        </div>
      );
    }
    function SecHead({ children }) {
      return (
        <div style={{display:"flex",alignItems:"center",gap:8,marginBottom:14}}>
          <div style={{width:3,height:16,background:C.blue,borderRadius:2}}/>
          <span style={{fontSize:12,color:C.muted,fontFamily:"monospace",letterSpacing:"0.1em",textTransform:"uppercase"}}>{children}</span>
        </div>
      );
    }
    function Btn({ children, onClick, color, active }) {
      return (
        <button onClick={onClick} style={{
          background: active?(color||C.blue):"transparent",
          color: active?"#000":(color||C.blue),
          border:`1px solid ${color||C.blue}`,
          borderRadius:5,padding:"5px 13px",cursor:"pointer",
          fontSize:11,fontFamily:"monospace",fontWeight:active?700:400,
          transition:"all 0.12s",
        }}>{children}</button>
      );
    }
    function CustomTT({ active, payload, label, labelFmt, valFmt }) {
      if (!active||!payload?.length) return null;
      return (
        <div style={{background:C.panel,border:`1px solid ${C.border}`,borderRadius:7,
          color:C.text,fontFamily:"monospace",fontSize:11,padding:"7px 11px"}}>
          <div style={{color:C.muted,marginBottom:3}}>x: {labelFmt?labelFmt(label):label}</div>
          {payload.map((p,i)=>(
            <div key={i} style={{color:p.color||C.text}}>
              {p.name}: {valFmt?valFmt(p.value):(typeof p.value==='number'?p.value.toPrecision(4):p.value)}
            </div>
          ))}
        </div>
      );
    }

    const TABS = [
      { id:"errors",     label:"α & β Curves"     },
      { id:"detect",     label:"Detection Prob."   },
      { id:"multidelta", label:"Multi-Δ Overlay"   },
      { id:"sweep",      label:"τ* vs ε Sweep"     },
      { id:"network",    label:"Network Bounds"    },
      { id:"wasted",     label:"Wasted Slots"      },
      { id:"chernoff",   label:"Chernoff Bound"    },
      { id:"median",     label:"Blockchain"        },
      { id:"builder",    label:"Block Builder"     },
    ];

    // ─── Main App ────────────────────────────────────────────────────────────────
    function DACalculator() {
      const [K,       setK]       = useState(1024);
      const [r,       setR]       = useState(2);
      const [S,       setS]       = useState(20);
      const [tau,     setTau]     = useState(13);
      const [Delta,   setDelta]   = useState(500);
      const [nNodes,  setNNodes]  = useState(100);
      const [epsilon, setEpsilon] = useState(0.0001);
      const [f,       setF]       = useState(0.0333);
      const [NB,      setNB]      = useState(1024);
      const [T_epoch, setT_epoch] = useState(388800);
      const [p_inv,   setP_inv]   = useState(0.6);
      const [p_tight, setP_tight] = useState(0.2);  // tight bound grey zone p (must be < 0.5)
      const [deltaList,   setDeltaList]   = useState("1,10,100,500");
      const [sweepSList,  setSweepSList]  = useState("10,20,50,100");
      const [simData,     setSimData]     = useState(null);
      const [simRunning,  setSimRunning]  = useState(false);
      const [simTrials,   setSimTrials]   = useState(200);
      const [q_conf,        setQ_conf]        = useState(0.99);
      const [bSimTrials,    setBSimTrials]    = useState(100);
      const [builderSimData,setBuilderSimData] = useState(null);
      const [bSimRunning,   setBSimRunning]   = useState(false);
      const [errSimData,     setErrSimData]    = useState(null);
      const [errSimRunning,  setErrSimRunning] = useState(false);
      const [mdSimData,      setMdSimData]     = useState(null);
      const [mdSimRunning,   setMdSimRunning]  = useState(false);
      const [netSimData,     setNetSimData]    = useState(null);
      const [netSimRunning,  setNetSimRunning] = useState(false);
      const [wastedSimData,  setWastedSimData] = useState(null);
      const [wastedSimRunning,setWastedSimRunning] = useState(false);
      const [chernSimData,   setChernSimData]  = useState(null);
      const [chernSimRunning,setChernSimRunning] = useState(false);
      const [tab, setTab] = useState("errors");

      const N = r * K;
      const lf = useMemo(() => makeLogFact(Math.max(N, 500) + 20), [N]);

      const stats = useMemo(() => {
        const a = pDetect(N, K, S, tau, lf);
        const NA2 = K + Delta;
        let b = 0;
        if (NA2 <= N) for (let g = 0; g < tau; g++) b += hyperPMF(N, NA2, S, g, lf);
        b = Math.min(1, b);
        const opt = findOptimalTau(N, K, Delta, S, lf);
        return { alpha: a, beta: b, optTau: opt.tau, optMaxErr: opt.maxErr };
      }, [N, K, S, tau, Delta, lf]);

      const errorData = useMemo(() => Array.from({length:S+1},(_,t)=>({
        tau:t,
        alpha:(()=>{const v=log10Alpha(N,K,S,t,lf);return isFinite(v)?v:null;})(),
        beta: (()=>{const v=log10Beta(N,K,Delta,S,t,lf);return isFinite(v)?v:null;})(),
      })), [N,K,S,Delta,lf]);

      const detectTheory = useMemo(() => Array.from({length:301},(_,i)=>{
        const NA = Math.round((i/300)*N);
        return { x:parseFloat((NA/N).toFixed(4)), theory:parseFloat((pDetect(N,NA,S,tau,lf)*nNodes).toFixed(3)) };
      }), [N,K,S,tau,nNodes,lf]);

      const runSimulation = useCallback(() => {
        setSimRunning(true);
        setTimeout(() => {
          const steps = 120;
          const result = Array.from({length:steps+1},(_,i)=>{
            const NA = Math.round((i/steps)*N);
            let hits = 0;
            for (let t=0; t<simTrials; t++) {
              if (sampleHypergeometric(N, NA, S) >= tau) hits++;
            }
            return { x:parseFloat((NA/N).toFixed(4)), sim:hits };
          });
          setSimData(result);
          setSimRunning(false);
        }, 30);
      }, [N, S, tau, simTrials]);

      const deltaArr = useMemo(() =>
        deltaList.split(",").map(s=>parseInt(s.trim())).filter(d=>!isNaN(d)&&d>0&&K+d<=N),
      [deltaList,K,N]);

      const multiDeltaData = useMemo(() => Array.from({length:S+1},(_,t)=>{
        const row = { tau:t };
        row["alpha"] = (()=>{const v=log10Alpha(N,K,S,t,lf);return isFinite(v)?v:null;})();
        deltaArr.forEach(d=>{
          const v=log10Beta(N,K,d,S,t,lf);
          row[`beta_${d}`]=isFinite(v)?v:null;
        });
        return row;
      }), [N,K,S,deltaArr,lf]);

      const sweepSArr = useMemo(() =>
        sweepSList.split(",").map(s=>parseInt(s.trim())).filter(s=>!isNaN(s)&&s>0&&s<=N),
      [sweepSList,N]);

      const sweepData = useMemo(() => {
        const k_list = [1,2,3,4,5,6];
        const eps_values = k_list.map(k => Math.pow(10,-k));

        const alphaByTauByS = {};
        sweepSArr.forEach(sv => {
          alphaByTauByS[sv] = Array.from({length:sv+1},(_,t) => pDetect(N,K,sv,t,lf));
        });

        return eps_values.map(eps => {
          const row = { log10eps: parseFloat(Math.log10(eps).toFixed(3)) };
          sweepSArr.forEach(sv => {
            const alphas = alphaByTauByS[sv];
            const DELTA_MAX = N - K - 1;
            let found = false, resBestTau = null, resBestDelta = null;

            // Correct algorithm: loop Delta from 1 upward (matching Python message__1_.txt)
            // Find globally minimal Delta where some tau satisfies both alpha<=eps, beta<=eps.
            // Among all such tau for that Delta, pick the one minimising max(alpha,beta).
            for (let d = 1; d <= DELTA_MAX; d++) {
              const NA2 = K + d;
              let bestMax = Infinity, bestTau = null;
              for (let t = 0; t <= sv; t++) {
                if (alphas[t] > eps) continue;
                let b = 0;
                for (let g = 0; g < t; g++) b += hyperPMF(N, NA2, sv, g, lf);
                b = Math.min(1, b);
                if (b <= eps) {
                  const mx = Math.max(alphas[t], b);
                  if (mx < bestMax) { bestMax = mx; bestTau = t; }
                }
              }
              if (bestTau !== null) {
                resBestDelta = d; resBestTau = bestTau; found = true; break;
              }
            }

            if (!found) {
              row[`tau_S${sv}`]=null; row[`delta_S${sv}`]=null;
              row[`kdnS${sv}`]=null;  row[`uhalf_S${sv}`]=null;
            } else {
              const uHalf = findUHalf(N, sv, resBestTau, lf);
              row[`tau_S${sv}`]   = resBestTau;
              row[`delta_S${sv}`] = resBestDelta;
              row[`kdnS${sv}`]    = parseFloat(((K+resBestDelta)/N).toFixed(4));
              row[`uhalf_S${sv}`] = uHalf!==null ? parseFloat((uHalf/N).toFixed(4)) : null;
            }
          });
          return row;
        });
      }, [N,K,sweepSArr,lf]);

      // Multi-NB network data — matching Python's NB_vals = [1,10,100,1024]
      const NB_VALS = [1, 10, 100, 1024];
      const NB_COLORS = [C.yellow, C.green, C.red, C.blue];

      const networkData = useMemo(() => Array.from({length:91},(_,i)=>{
        const n=i+10, half=Math.ceil(n/2);
        const row = {n};
        NB_VALS.forEach(nb=>{
          // Model B (unrecover): 2^n * ε^(nb * ⌈n/2⌉)
          const log10_u = n*Math.log10(2) + nb*half*Math.log10(epsilon);
          row[`unrec_${nb}`] = isFinite(log10_u) ? parseFloat(log10_u.toFixed(3)) : null;
          // Model A (recover): 2^n * (1-(1-ε)^nb)^⌈n/2⌉
          const fac = 1 - Math.pow(1-epsilon, nb);
          const log10_r = fac>0 ? n*Math.log10(2)+half*Math.log10(fac) : null;
          row[`rec_${nb}`] = log10_r!==null&&isFinite(log10_r) ? parseFloat(log10_r.toFixed(3)) : null;
        });
        return row;
      }), [epsilon]);

      const wastedData = useMemo(() => Array.from({length:91},(_,i)=>{
        const n=i+10, half=Math.ceil(n/2);
        // Code 2 — Basic upper bound: T·f·2^n·(1−(1−ε)^NB)^⌈n/2⌉
        const fac=1-Math.pow(1-epsilon,NB);
        const lv=Math.log10(T_epoch*f)+n*Math.log10(2)+half*Math.log10(fac>0?fac:1e-300);
        const basic=Math.pow(10,lv);
        // Code 3 — Tight upper bound: T·f·(4p(1−p))^(n/2), p_tight < 0.5 (grey zone)
        const p_t = Math.min(p_tight, 0.499);
        const base4 = 4*p_t*(1-p_t);
        const tight = (base4>0&&base4<1) ? T_epoch*f*Math.pow(base4,n/2) : null;
        // Code 4 — Lower bound: T·f·(1−exp(−n·D((⌈n/2⌉−1)/n ‖ p_inv))), p_inv > 0.5
        const q_lb = (half-1)/n;
        let lower = null;
        if(p_inv>0.5 && q_lb>0 && q_lb<1){
          const kl=KL(q_lb,p_inv);
          if(isFinite(kl)&&kl>=0) lower=parseFloat((T_epoch*f*Math.max(0,1-Math.exp(-n*kl))).toFixed(2));
        }
        const w  = isFinite(basic)&&basic>0  ? parseFloat(basic.toFixed(2))  : null;
        const tg = tight!==null&&isFinite(tight)&&tight>0 ? parseFloat(tight.toFixed(4)) : null;
        return {
          n, wasted:w, tight:tg, lower,
          log10_wasted: w   ? parseFloat(Math.log10(w).toFixed(3))  : null,
          log10_tight:  tg  ? parseFloat(Math.log10(tg).toFixed(3)) : null,
          log10_lower:  lower&&lower>0 ? parseFloat(Math.log10(lower).toFixed(3)) : null,
        };
      }), [epsilon,NB,T_epoch,f,p_tight,p_inv]);

      // Blockchain data — two panels matching Python Code 1
      // SPY = 31536000 (365 days, matching Python's seconds_per_year)
      const blockchainData = useMemo(() => {
        const SPY = 31536000;
        return Array.from({length:91},(_,i)=>{
          const n=i+10, half=Math.ceil(n/2);
          // y1 = f · 2^n · ε^⌈n/2⌉  — prob. invalid block accepted by majority (NB=1 blockchain view)
          const log10_y1 = Math.log10(f) + n*Math.log10(2) + half*Math.log10(epsilon);
          // y2 = ⌈ln(2)·(2^(−n)·ε^(−⌈n/2⌉) − f)/f⌉ / SPY  — median time (corrected formula with −f)
          const inner = Math.LN2 * (Math.pow(2,-n) * Math.pow(epsilon,-half) - f) / f;
          const y2_years = inner > 0 ? Math.ceil(inner) / SPY : null;
          const log10_y2 = y2_years && y2_years > 0 ? Math.log10(y2_years) : null;
          return {
            n,
            log10_y1: isFinite(log10_y1) ? parseFloat(log10_y1.toFixed(3)) : null,
            log10_y2: log10_y2!==null&&isFinite(log10_y2) ? parseFloat(log10_y2.toFixed(3)) : null,
          };
        });
      }, [epsilon, f]);

      // Chernoff — both regimes simultaneously (Code 3 + Code 4)
      const chernoffData = useMemo(() => Array.from({length:91},(_,i)=>{
        const n=i+10, q=(Math.ceil(n/2)-1)/n;
        // Code 3 tight UPPER bound: exp(−n·KL(1/2‖p_tight)) = (4p(1−p))^(n/2), requires p_tight < 0.5
        let tight_upper=null, log10_tight=null;
        if(p_tight>0 && p_tight<0.5){
          const kl=KL(0.5,p_tight);
          if(isFinite(kl)&&kl>=0){
            tight_upper=parseFloat(Math.exp(-n*kl).toFixed(8));
            const lt=-n*kl*Math.LOG10E;
            log10_tight=isFinite(lt)?parseFloat(lt.toFixed(3)):null;
          }
        }
        // Code 4 LOWER bound: 1−exp(−n·KL(q‖p_inv)), requires p_inv > 0.5
        let lower_bound = null;
        if(p_inv>0.5 && q>0 && q<1){
          const kl=KL(q,p_inv);
          if(isFinite(kl)&&kl>=0) lower_bound=parseFloat(Math.max(0,1-Math.exp(-n*kl)).toFixed(8));
        }
        return {n, tight_upper, log10_tight, lower_bound};
      }), [p_tight, p_inv]);

      // Block-builder data: negative-binomial hitting time τ_{NB,q}
      // Three datasets: unrecoverable (p=ε), recoverable (p=1-ε), grey zone (fixed p)
      const builderData = useMemo(() => {
        const zq = zQuantile(q_conf);
        return BUILDER_NB.map(NB => {
          const row = {NB};
          // Unrecoverable case: p = ε  (approx formula; exact where numerically feasible)
          EPS_VALS.forEach((eps,ki)=>{
            const approx = negBinApprox(NB, eps, zq);
            const exact  = negBinExact(NB, eps, q_conf);
            row[`u_approx_${ki}`] = approx ? parseFloat(approx.toFixed(1)) : null;
            row[`u_exact_${ki}`]  = exact  ? parseFloat(exact)             : null;
            row[`u_log10_${ki}`]  = approx&&approx>0 ? parseFloat(Math.log10(approx).toFixed(3)) : null;
          });
          // Recoverable case: p = 1−ε  (tau ≈ NB for small ε)
          EPS_VALS.forEach((eps,ki)=>{
            const approx = negBinApprox(NB, 1-eps, zq);
            row[`r_approx_${ki}`] = approx ? parseFloat(approx.toFixed(1)) : null;
          });
          // Grey-zone case: fixed p in (0,1)
          PGREY_VALS.forEach((p,pi)=>{
            const approx = negBinApprox(NB, p, zq);
            row[`g_approx_${pi}`] = approx ? parseFloat(approx.toFixed(1)) : null;
            row[`g_log10_${pi}`]  = approx&&approx>0 ? parseFloat(Math.log10(approx).toFixed(3)) : null;
          });
          return row;
        });
      }, [q_conf]);

      // Builder simulation: runs NegBin MC for all panels
      // Grey zone (all 4 p vals, always feasible) + Recoverable (all 4 eps, always fast)
      // Unrecoverable: only eps=0.1 (larger NB/p is too slow for browser)
      const runBuilderSim = useCallback(() => {
        setBSimRunning(true);
        setTimeout(() => {
          const zq = zQuantile(q_conf);
          const result = BUILDER_NB.map(nb => {
            const row = { NB: nb };
            // Grey zone — all 4 p values (p in 0.2..0.7, always feasible)
            PGREY_VALS.forEach((p, pi) => {
              const v = simNegBin(nb, p, bSimTrials, q_conf);
              row[`g_sim_${pi}`]      = v ? parseFloat(v) : null;
              row[`g_sim_log10_${pi}`]= v && v > 0 ? parseFloat(Math.log10(v).toFixed(3)) : null;
            });
            // Recoverable — p = 1-eps (p close to 1, always fast)
            EPS_VALS.forEach((eps, ki) => {
              const v = simNegBin(nb, 1 - eps, bSimTrials, q_conf);
              row[`r_sim_${ki}`] = v ? parseFloat(v) : null;
            });
            // Unrecoverable — only eps=0.1 feasible (p=0.1, NB/p <= 10240)
            const v_u = simNegBin(nb, EPS_VALS[0], bSimTrials, q_conf);
            row[`u_sim_log10_0`] = v_u && v_u > 0 ? parseFloat(Math.log10(v_u).toFixed(3)) : null;
            return row;
          });
          setBuilderSimData(result);
          setBSimRunning(false);
        }, 30);
      }, [q_conf, bSimTrials]);

      // Merge theory + sim data by NB key
      const builderMerged = useMemo(() => {
        if (!builderSimData) return builderData;
        const simMap = new Map(builderSimData.map(d => [d.NB, d]));
        return builderData.map(d => ({ ...d, ...(simMap.get(d.NB) || {}) }));
      }, [builderData, builderSimData]);

      const runErrSim = useCallback(()=>{
        setErrSimRunning(true);
        setTimeout(()=>{
          const result = Array.from({length:S+1},(_,t)=>{
            let ah=0,bh=0;
            for(let i=0;i<simTrials;i++){
              if(sampleHypergeometric(N,K,S)>=t) ah++;
              if(sampleHypergeometric(N,K+Delta,S)<t) bh++;
            }
            const af=ah/simTrials,bf=bh/simTrials;
            return{tau:t,
              alpha_sim:af>0?parseFloat(Math.log10(af).toFixed(3)):null,
              beta_sim: bf>0?parseFloat(Math.log10(bf).toFixed(3)):null};
          });
          setErrSimData(result); setErrSimRunning(false);
        },30);
      },[N,K,Delta,S,simTrials]);

      const errorDataMerged = useMemo(()=>{
        if(!errSimData) return errorData;
        const m=new Map(errSimData.map(d=>[d.tau,d]));
        return errorData.map(d=>({...d,...(m.get(d.tau)||{})}));
      },[errorData,errSimData]);

      const runMdSim = useCallback(()=>{
        setMdSimRunning(true);
        setTimeout(()=>{
          const result = Array.from({length:S+1},(_,t)=>{
            let ah=0; const bh={}; deltaArr.forEach(d=>{bh[d]=0;});
            for(let i=0;i<simTrials;i++){
              if(sampleHypergeometric(N,K,S)>=t) ah++;
              deltaArr.forEach(d=>{if(sampleHypergeometric(N,K+d,S)<t) bh[d]++;});
            }
            const af=ah/simTrials;
            const row={tau:t,alpha_sim:af>0?parseFloat(Math.log10(af).toFixed(3)):null};
            deltaArr.forEach(d=>{const bf=bh[d]/simTrials;row[`beta_sim_${d}`]=bf>0?parseFloat(Math.log10(bf).toFixed(3)):null;});
            return row;
          });
          setMdSimData(result); setMdSimRunning(false);
        },30);
      },[N,K,deltaArr,S,simTrials]);

      const multiDeltaMerged = useMemo(()=>{
        if(!mdSimData) return multiDeltaData;
        const m=new Map(mdSimData.map(d=>[d.tau,d]));
        return multiDeltaData.map(d=>({...d,...(m.get(d.tau)||{})}));
      },[multiDeltaData,mdSimData]);

      const runNetSim = useCallback(()=>{
        setNetSimRunning(true);
        setTimeout(()=>{
          const result=Array.from({length:91},(_,i)=>{
            const n=i+10; const row={n};
            NB_VALS.forEach(nb=>{
              const pu=Math.pow(epsilon,nb), pr=1-Math.pow(1-epsilon,nb);
              const su=pu>1e-15?simMajority(n,pu,simTrials):0;
              const sr=simMajority(n,pr,simTrials);
              row[`unrec_sim_${nb}`]=su>0?parseFloat(Math.log10(su).toFixed(3)):null;
              row[`rec_sim_${nb}`]=sr>0?parseFloat(Math.log10(sr).toFixed(3)):null;
            });
            return row;
          });
          setNetSimData(result); setNetSimRunning(false);
        },30);
      },[epsilon,simTrials]);

      const networkMerged = useMemo(()=>{
        if(!netSimData) return networkData;
        const m=new Map(netSimData.map(d=>[d.n,d]));
        return networkData.map(d=>({...d,...(m.get(d.n)||{})}));
      },[networkData,netSimData]);

      const runWastedSim = useCallback(()=>{
        setWastedSimRunning(true);
        setTimeout(()=>{
          const pb=1-Math.pow(1-epsilon,NB), pt=Math.min(p_tight,0.499), pi=p_inv>0.5?p_inv:null;
          const result=Array.from({length:91},(_,i)=>{
            const n=i+10;
            const s2=simMajority(n,pb,simTrials),s3=simMajority(n,pt,simTrials),s4=pi?simMajority(n,pi,simTrials):null;
            const w2=T_epoch*f*s2,w3=T_epoch*f*s3,w4=pi?T_epoch*f*s4:null;
            return{n,
              log10_wasted_sim:w2>0?parseFloat(Math.log10(w2).toFixed(3)):null,
              log10_tight_sim: w3>0?parseFloat(Math.log10(w3).toFixed(3)):null,
              log10_lower_sim: w4&&w4>0?parseFloat(Math.log10(w4).toFixed(3)):null};
          });
          setWastedSimData(result); setWastedSimRunning(false);
        },30);
      },[epsilon,NB,T_epoch,f,p_tight,p_inv,simTrials]);

      const wastedMerged = useMemo(()=>{
        if(!wastedSimData) return wastedData;
        const m=new Map(wastedSimData.map(d=>[d.n,d]));
        return wastedData.map(d=>({...d,...(m.get(d.n)||{})}));
      },[wastedData,wastedSimData]);

      const runChernSim = useCallback(()=>{
        setChernSimRunning(true);
        setTimeout(()=>{
          const pt=p_tight>0&&p_tight<0.5?p_tight:null, pi=p_inv>0.5?p_inv:null;
          const result=Array.from({length:91},(_,i)=>{
            const n=i+10;
            const s3=pt?simMajority(n,pt,simTrials):null, s4=pi?simMajority(n,pi,simTrials):null;
            return{n,
              sim_tight:s3&&s3>0?parseFloat(Math.log10(s3).toFixed(3)):null,
              sim_lower:s4!==null?parseFloat(s4.toFixed(6)):null};
          });
          setChernSimData(result); setChernSimRunning(false);
        },30);
      },[p_tight,p_inv,simTrials]);

      const chernMerged = useMemo(()=>{
        if(!chernSimData) return chernoffData;
        const m=new Map(chernSimData.map(d=>[d.n,d]));
        return chernoffData.map(d=>({...d,...(m.get(d.n)||{})}));
      },[chernoffData,chernSimData]);

      const detectMerged = useMemo(()=>{
        if(!simData) return detectTheory;
        const map=new Map(simData.map(d=>[d.x,d.sim]));
        return detectTheory.map(d=>({...d,sim:map.get(d.x)??null}));
      },[detectTheory,simData]);

      const KN  = K/N;
      const KDN = Math.min((K+Delta)/N, 1);
      const ML=55, MR=20;

      return (
        <div style={{background:C.bg,minHeight:"100vh",color:C.text,padding:"20px 18px"}}>

          {/* Header */}
          <div style={{marginBottom:22}}>
            <div style={{fontSize:10,letterSpacing:"0.18em",color:C.muted,fontFamily:"monospace",marginBottom:5}}>
              DATA AVAILABILITY SAMPLING — PARAMETRIC CALCULATOR
            </div>
            <h1 style={{margin:0,fontSize:21,fontWeight:700,color:C.text,letterSpacing:"-0.02em"}}>
              DA Sampling Analysis
            </h1>
            <div style={{marginTop:3,fontSize:11,color:C.muted}}>
              N = r·K = <span style={{color:C.blue,fontFamily:"monospace"}}>{N}</span>
              &nbsp;·&nbsp; K/N = <span style={{color:C.green,fontFamily:"monospace"}}>{(K/N).toFixed(3)}</span>
              &nbsp;·&nbsp; Recoverable if N_A ≥ <span style={{color:C.green,fontFamily:"monospace"}}>{K+1}</span>
            </div>
          </div>

          {/* Parameters */}
          <div style={{background:C.panel,border:`1px solid ${C.border}`,borderRadius:10,padding:"16px 20px",marginBottom:16}}>
            <SecHead>DA Sampling Parameters</SecHead>
            <div style={{display:"flex",flexWrap:"wrap",gap:14,alignItems:"flex-end"}}>
              <ParamInput label="K"             value={K}      onChange={setK}      min={1} />
              <ParamInput label="r"             value={r}      onChange={setR}      min={1} max={16} />
              <ParamInput label="S (sample)"    value={S}      onChange={setS}      min={1} max={N} />
              <ParamInput label="τ (threshold)" value={tau}    onChange={setTau}    min={0} max={S} />
              <ParamInput label="Δ (margin)"    value={Delta}  onChange={setDelta}  min={1} max={N-K} />
              <ParamInput label="n (nodes)"     value={nNodes} onChange={setNNodes} min={1} />
              <Btn color={C.green} active={false} onClick={()=>setTau(stats.optTau)}>
                Auto τ* = {stats.optTau}
              </Btn>
            </div>
            <div style={{height:1,background:C.border,margin:"14px 0"}}/>
            <SecHead>Blockchain / Network Parameters</SecHead>
            <div style={{display:"flex",flexWrap:"wrap",gap:14,alignItems:"flex-end"}}>
              <ParamInput label="ε (error bound)"  value={epsilon} onChange={setEpsilon} step={0.0001} min={1e-10} max={1} />
              <ParamInput label="f (slot prob)"    value={f}       onChange={setF}       step={0.001}  min={0}     max={1} />
              <ParamInput label="N_B (blobs)"      value={NB}      onChange={setNB}      min={1}       max={1024} />
              <ParamInput label="T (slots/epoch)"  value={T_epoch} onChange={setT_epoch} min={1} />
              <ParamInput label="p (block inval.)" value={p_inv}   onChange={setP_inv}   step={0.05}   min={0.01}  max={0.99} />
              <ParamInput label="p_tight (grey zone, &lt;0.5)" value={p_tight} onChange={setP_tight} step={0.01} min={0.01} max={0.49} />
              <Btn color={C.teal} active={false} onClick={()=>setP_tight(parseFloat(Math.min(0.499,(1-Math.pow(1-epsilon,NB))+0.1).toFixed(4)))}>
                Auto p_tight
              </Btn>
            </div>
          </div>

          {/* Stats bar */}
          <div style={{display:"flex",flexWrap:"wrap",gap:8,marginBottom:16}}>
            <StatCard label="α(τ) — Type I"        value={stats.alpha.toExponential(3)}   color={C.blue}   />
            <StatCard label="β(τ,Δ) — Type II"     value={stats.beta.toExponential(3)}    color={C.red}    />
            <StatCard label="Optimal τ*"            value={`${stats.optTau}  (ε*≈${stats.optMaxErr.toExponential(1)})`} color={C.green} />
            <StatCard label="N = r·K"               value={N} />
            <StatCard label="Grey zone Δ/N"         value={`${((KDN-KN)*100).toFixed(1)}%`} color={C.purple} />
            <StatCard label="Avg non-empty/epoch"   value={Math.round(T_epoch*f).toLocaleString()} color={C.yellow} />
          </div>

          {/* Tab bar */}
          <div style={{display:"flex",gap:3,marginBottom:14,flexWrap:"wrap"}}>
            {TABS.map(t=>(
              <button key={t.id} onClick={()=>setTab(t.id)} style={{
                background:tab===t.id?C.blue:C.panel, color:tab===t.id?"#000":C.muted,
                border:`1px solid ${tab===t.id?C.blue:C.border}`,
                borderRadius:5,padding:"5px 13px",cursor:"pointer",
                fontSize:11,fontFamily:"monospace",fontWeight:tab===t.id?700:400,transition:"all 0.12s",
              }}>{t.label}</button>
            ))}
          </div>

          {/* Chart panel */}
          <div style={{background:C.panel,border:`1px solid ${C.border}`,borderRadius:10,padding:"18px 14px"}}>

            {/* α & β CURVES */}
            {tab==="errors" && (
              <>
                <SecHead>α(τ) and β(τ,Δ) vs threshold τ — log₁₀ scale</SecHead>
                <div style={{fontSize:11,color:C.muted,marginBottom:10}}>
                  K={K}, r={r}, N={N}, S={S}, Δ={Delta}
                  &nbsp;·&nbsp;<span style={{color:C.blue}}>α(τ)</span> = Type I (false positive at N_A=K)
                  &nbsp;·&nbsp;<span style={{color:C.red}}>β(τ,Δ)</span> = Type II (miss at N_A=K+Δ)
                </div>
                <div style={{display:"flex",alignItems:"center",gap:12,marginBottom:12,flexWrap:"wrap"}}>
                  <label style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>Trials/τ:</label>
                  <input type="number" value={simTrials} min={50} max={5000} step={50}
                    onChange={e=>setSimTrials(Math.max(50,parseInt(e.target.value)||200))}
                    style={{background:C.bg,border:`1px solid ${C.border}`,borderRadius:5,
                      color:C.text,fontFamily:"monospace",fontSize:12,padding:"3px 7px",width:80,outline:"none"}}/>
                  <Btn color={C.green} active={!!errSimData} onClick={runErrSim}>
                    {errSimRunning?"Running…":errSimData?"Re-run Simulation":"▶ Run Simulation"}
                  </Btn>
                  {errSimData && <Btn color={C.red} active={false} onClick={()=>setErrSimData(null)}>✕ Clear</Btn>}
                  {errSimData && <span style={{fontSize:11,color:C.green,fontFamily:"monospace"}}>✓ Squares = empirical α/β from {simTrials} hypergeometric draws/τ</span>}
                </div>
                <ResponsiveContainer width="100%" height={380}>
                  <ComposedChart data={errorDataMerged} margin={{left:20,right:20,top:10,bottom:22}}>
                    <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                    <XAxis dataKey="tau" stroke={C.muted}
                      tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                      label={{value:"τ",position:"insideBottom",offset:-10,fill:C.muted,fontSize:13}}/>
                    <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                      tickFormatter={v=>`10^${v.toFixed(0)}`}
                      label={{value:"log₁₀(prob)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:11}}/>
                    <Tooltip content={<CustomTT labelFmt={v=>`τ=${v}`} valFmt={v=>`10^(${v?.toFixed(2)})`}/>}/>
                    <Legend wrapperStyle={{fontSize:11,fontFamily:"monospace"}}/>
                    <ReferenceLine x={tau} stroke={C.green} strokeDasharray="5 3"
                      label={{value:`τ=${tau}`,fill:C.green,fontSize:10}}/>
                    <Line type="monotone" dataKey="alpha" name="α theory" stroke={C.blue} dot={false} strokeWidth={2} connectNulls={false}/>
                    <Line type="monotone" dataKey="beta"  name="β theory" stroke={C.red}  dot={false} strokeWidth={2} connectNulls={false}/>
                    {errSimData&&<Scatter dataKey="alpha_sim" name="α sim" fill={C.blue} shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.blue} opacity={0.85}/>}}/>}
                    {errSimData&&<Scatter dataKey="beta_sim"  name="β sim" fill={C.red}  shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.red}  opacity={0.85}/>}}/>}
                  </ComposedChart>
                </ResponsiveContainer>
              </>
            )}

            {/* DETECTION PROBABILITY */}
            {tab==="detect" && (
              <>
                <SecHead>Detection probability vs N_A/N</SecHead>
                <div style={{display:"flex",alignItems:"center",gap:12,marginBottom:14,flexWrap:"wrap"}}>
                  <div style={{display:"flex",alignItems:"center",gap:8}}>
                    <label style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>Trials/point:</label>
                    <input type="number" value={simTrials} min={10} max={5000} step={50}
                      onChange={e=>setSimTrials(parseInt(e.target.value))}
                      style={{background:C.bg,border:`1px solid ${C.border}`,borderRadius:5,
                        color:C.text,fontFamily:"monospace",fontSize:12,padding:"3px 7px",width:80,outline:"none"}}/>
                  </div>
                  <Btn color={C.green} active={!!simData} onClick={runSimulation}>
                    {simRunning?"Running…":simData?"Re-run Simulation":"▶ Run Simulation"}
                  </Btn>
                  {simData && <Btn color={C.red} active={false} onClick={()=>setSimData(null)}>✕ Clear</Btn>}
                  <span style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>τ={tau} · S={S} · n={nNodes}</span>
                </div>
                <div style={{display:"flex",gap:18,marginBottom:12,flexWrap:"wrap",fontSize:11,fontFamily:"monospace",color:C.muted}}>
                  {[
                    {color:C.blue,sw:2.5,dash:"none",label:"Theory: n × P(n_A ≥ τ | N_A)"},
                    simData&&{color:C.red,dot:true,label:"Simulation"},
                    {color:C.red, sw:1.5,dash:"7 4", label:`K/N = ${KN.toFixed(3)}`},
                    {color:C.blue,sw:1.5,dash:"7 4", label:`(K+Δ)/N = ${KDN.toFixed(3)}`},
                    {color:"#666",sw:1,  dash:"none", label:"n/2"},
                  ].filter(Boolean).map(({color,sw,dash,label,dot})=>(
                    <div key={label} style={{display:"flex",alignItems:"center",gap:5}}>
                      {dot
                        ? <svg width={14} height={10}><rect x={4} y={2} width={6} height={6} fill={color}/></svg>
                        : <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={color} strokeWidth={sw} strokeDasharray={dash}/></svg>}
                      <span>{label}</span>
                    </div>
                  ))}
                </div>
                <div style={{position:"relative"}}>
                  <ResponsiveContainer width="100%" height={440}>
                    <ComposedChart data={detectMerged} margin={{left:ML,right:MR,top:16,bottom:36}}>
                      <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                      <XAxis dataKey="x" stroke={C.muted} type="number" domain={[0,1]}
                        tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                        tickFormatter={v=>v.toFixed(2)}
                        label={{value:"N_A / N",position:"insideBottom",offset:-18,fill:C.muted,fontSize:13}}/>
                      <YAxis stroke={C.muted} tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                        domain={[0,nNodes]}
                        label={{value:"Count of successes out of n",angle:-90,position:"insideLeft",offset:10,fill:C.muted,fontSize:10}}/>
                      <Tooltip content={<CustomTT labelFmt={v=>v?.toFixed(3)} valFmt={v=>v?.toFixed(2)}/>}/>
                      <ReferenceArea x1={0}   x2={KN}  fill={C.red}    fillOpacity={0.07} stroke="none"/>
                      <ReferenceArea x1={KN}  x2={KDN} fill={C.purple} fillOpacity={0.07} stroke="none"/>
                      <ReferenceArea x1={KDN} x2={1}   fill={C.green}  fillOpacity={0.07} stroke="none"/>
                      <ReferenceLine x={KN}  stroke={C.red}  strokeDasharray="7 4" strokeWidth={1.8}/>
                      <ReferenceLine x={KDN} stroke={C.blue} strokeDasharray="7 4" strokeWidth={1.8}/>
                      <ReferenceLine y={nNodes/2} stroke="#555" strokeWidth={1}
                        label={{value:"n/2",position:"insideRight",fill:"#666",fontSize:10}}/>
                      <Line type="monotone" dataKey="theory" name="Theory"
                        stroke={C.blue} dot={false} strokeWidth={2.5} connectNulls/>
                      {simData && (
                        <Scatter dataKey="sim" name="Simulation" fill={C.red}
                          shape={(props)=>{
                            const {cx,cy}=props;
                            if(cx==null||cy==null) return null;
                            return <rect x={cx-3} y={cy-3} width={6} height={6} fill={C.red} opacity={0.85}/>;
                          }}/>
                      )}
                    </ComposedChart>
                  </ResponsiveContainer>
                  {/* Annotation boxes */}
                  <div style={{position:"absolute",
                    left:`calc(${ML}px + ${(KN/2)*100}% * (1 - ${ML+MR}px / 100%))`,
                    bottom:62,transform:"translateX(-50%)",
                    background:C.panel,border:`1.5px solid ${C.red}`,borderRadius:6,
                    padding:"5px 10px",fontSize:11,fontFamily:"monospace",
                    color:C.red,pointerEvents:"none",whiteSpace:"nowrap",zIndex:10}}>
                    <div style={{fontWeight:700}}>Data is unrecover.</div>
                    <div style={{color:C.muted}}>with prob. ≥ 1−ε</div>
                  </div>
                  <div style={{position:"absolute",
                    left:`calc(${ML}px + ${((KN+KDN)/2)*100}% * (1 - ${ML+MR}px / 100%))`,
                    top:"40%",transform:"translateX(-50%)",
                    background:C.panel,border:`1.5px solid ${C.purple}`,borderRadius:6,
                    padding:"5px 10px",fontSize:11,fontFamily:"monospace",
                    color:C.purple,pointerEvents:"none",whiteSpace:"nowrap",zIndex:10}}>
                    <div style={{fontWeight:700}}>Data is recover.</div>
                    <div style={{color:C.muted}}>with prob. ∈ (ε, 1−ε)</div>
                  </div>
                  <div style={{position:"absolute",
                    left:`calc(${ML}px + ${((KDN+1)/2)*100}% * (1 - ${ML+MR}px / 100%))`,
                    top:26,transform:"translateX(-50%)",
                    background:C.panel,border:`1.5px solid ${C.blue}`,borderRadius:6,
                    padding:"5px 10px",fontSize:11,fontFamily:"monospace",
                    color:C.blue,pointerEvents:"none",whiteSpace:"nowrap",zIndex:10}}>
                    <div style={{fontWeight:700}}>Data is recover.</div>
                    <div style={{color:C.muted}}>with prob. ≥ 1−ε</div>
                  </div>
                </div>
                <div style={{display:"flex",gap:8,marginTop:12,flexWrap:"wrap"}}>
                  <StatCard label="α(τ)"         value={stats.alpha.toExponential(3)} color={C.red}/>
                  <StatCard label="β(τ,Δ)"        value={stats.beta.toExponential(3)} color={C.blue}/>
                  <StatCard label="Grey zone Δ/N" value={`${((KDN-KN)*100).toFixed(1)}%`} color={C.purple}/>
                  <StatCard label="Optimal τ*"    value={stats.optTau} color={C.green}/>
                </div>
              </>
            )}

            {/* MULTI-Δ OVERLAY */}
            {tab==="multidelta" && (
              <>
                <SecHead>α(τ) and β(τ,Δ) for multiple Δ values — log₁₀ scale</SecHead>
                <div style={{display:"flex",alignItems:"center",gap:10,marginBottom:14,flexWrap:"wrap"}}>
                  <label style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>Δ values (comma-separated):</label>
                  <input value={deltaList} onChange={e=>setDeltaList(e.target.value)}
                    style={{background:C.bg,border:`1px solid ${C.border}`,borderRadius:5,
                      color:C.text,fontFamily:"monospace",fontSize:12,padding:"4px 10px",width:240,outline:"none"}}/>
                  <span style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>K={K}, r={r}, N={N}, S={S}</span>
                </div>
                <div style={{display:"flex",alignItems:"center",gap:12,marginBottom:10,flexWrap:"wrap"}}>
                  <Btn color={C.green} active={!!mdSimData} onClick={runMdSim}>
                    {mdSimRunning?"Running…":mdSimData?"Re-run Simulation":"▶ Run Simulation"}
                  </Btn>
                  {mdSimData&&<Btn color={C.red} active={false} onClick={()=>setMdSimData(null)}>✕ Clear</Btn>}
                  {mdSimData&&<span style={{fontSize:11,color:C.green,fontFamily:"monospace"}}>✓ Squares = empirical α/β ({simTrials} draws/τ)</span>}
                </div>
                <div style={{display:"flex",gap:16,marginBottom:14,flexWrap:"wrap",fontSize:11,fontFamily:"monospace",color:C.muted}}>
                  <div style={{display:"flex",alignItems:"center",gap:5}}>
                    <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={C.blue} strokeWidth={2}/></svg>
                    <span>α(τ) — independent of Δ</span>
                  </div>
                  {deltaArr.map((d,i)=>(
                    <div key={d} style={{display:"flex",alignItems:"center",gap:5}}>
                      <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={MULTI_DELTA_COLORS[i%5]} strokeWidth={1.8} strokeDasharray="5 2"/></svg>
                      <span>β(τ, Δ={d})</span>
                    </div>
                  ))}
                </div>
                <ResponsiveContainer width="100%" height={400}>
                  <ComposedChart data={multiDeltaMerged} margin={{left:20,right:20,top:10,bottom:22}}>
                    <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                    <XAxis dataKey="tau" stroke={C.muted}
                      tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                      label={{value:"τ",position:"insideBottom",offset:-10,fill:C.muted,fontSize:13}}/>
                    <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                      tickFormatter={v=>`10^${v.toFixed(0)}`}
                      label={{value:"log₁₀(prob)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:11}}/>
                    <Tooltip content={<CustomTT labelFmt={v=>`τ=${v}`} valFmt={v=>`10^(${v?.toFixed(2)})`}/>}/>
                    <ReferenceLine x={tau} stroke={C.green} strokeDasharray="5 3"
                      label={{value:`τ=${tau}`,fill:C.green,fontSize:10}}/>
                    <Line type="monotone" dataKey="alpha" name="α theory" stroke={C.blue} dot={false} strokeWidth={2.2} connectNulls={false}/>
                    {deltaArr.map((d,i)=>(
                      <Line key={`tl_${d}`} type="monotone" dataKey={`beta_${d}`} name={`β theory Δ=${d}`}
                        stroke={MULTI_DELTA_COLORS[i%5]} dot={false} strokeWidth={1.8} strokeDasharray="5 2" connectNulls={false}/>
                    ))}
                    {mdSimData&&<Scatter dataKey="alpha_sim" name="α sim" fill={C.blue} shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.blue} opacity={0.85}/>}}/>}
                    {mdSimData&&deltaArr.map((d,i)=>(
                      <Scatter key={`ms_${d}`} dataKey={`beta_sim_${d}`} name={`β sim Δ=${d}`} fill={MULTI_DELTA_COLORS[i%5]}
                        shape={pp=>{const{cx,cy}=pp;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={MULTI_DELTA_COLORS[i%5]} opacity={0.85}/>}}/>
                    ))}
                  </ComposedChart>
                </ResponsiveContainer>
              </>
            )}

            {/* τ* vs ε SWEEP */}
            {tab==="sweep" && (
              <>
                <SecHead>Optimal τ*, Δ* and N_A(1/2)/N vs error bound ε — multiple S values</SecHead>
                <div style={{display:"flex",alignItems:"center",gap:10,marginBottom:10,flexWrap:"wrap"}}>
                  <label style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>S values (comma-separated):</label>
                  <input value={sweepSList} onChange={e=>setSweepSList(e.target.value)}
                    style={{background:C.bg,border:`1px solid ${C.border}`,borderRadius:5,
                      color:C.text,fontFamily:"monospace",fontSize:12,padding:"4px 10px",width:200,outline:"none"}}/>
                  <span style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>K={K}, r={r}, N={N}</span>
                </div>

                {/* ε upper-bound warning from N_B */}
                {(() => {
                  const epsMax = 1 - Math.pow(3/4, 1/NB);
                  return (
                    <div style={{marginBottom:14,padding:"7px 12px",borderRadius:6,
                      background:"rgba(210,153,34,0.08)",border:`1px solid ${C.yellow}`,
                      fontSize:11,fontFamily:"monospace",color:C.yellow}}>
                      ⚠ For N_B={NB} blobs, ε must satisfy ε &lt; 1−(3/4)^(1/N_B) ≈ {epsMax.toExponential(3)} to keep network bounds decreasing with n.
                      &nbsp;Current ε={epsilon} is {epsilon < epsMax ? <span style={{color:C.green}}>✓ valid</span> : <span style={{color:C.red}}>✗ too large — reduce ε or decrease N_B</span>}.
                    </div>
                  );
                })()}

                {/* Color legend */}
                <div style={{display:"flex",gap:16,marginBottom:14,flexWrap:"wrap",fontSize:11,fontFamily:"monospace",color:C.muted}}>
                  {sweepSArr.map((sv,i)=>(
                    <div key={sv} style={{display:"flex",alignItems:"center",gap:10}}>
                      <div style={{display:"flex",alignItems:"center",gap:4}}>
                        <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={MULTI_S_COLORS[i%4]} strokeWidth={2} strokeDasharray="5 2"/></svg>
                        <span style={{color:MULTI_S_COLORS[i%4]}}>N_A(1/2)/N, S={sv}</span>
                      </div>
                      <div style={{display:"flex",alignItems:"center",gap:4}}>
                        <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={MULTI_S_COLORS[i%4]} strokeWidth={2}/></svg>
                        <span style={{color:MULTI_S_COLORS[i%4]}}>(K+Δ*)/N, S={sv}</span>
                      </div>
                    </div>
                  ))}
                </div>

                {/* Top row: τ* and Δ* panels side by side */}
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:16,marginBottom:20}}>
                  {/* τ* vs ε */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:6,textAlign:"center"}}>
                      Optimal τ* vs ε
                    </div>
                    <ResponsiveContainer width="100%" height={280}>
                      <LineChart data={sweepData} margin={{left:20,right:10,top:8,bottom:30}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="log10eps" stroke={C.muted}
                          tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"ε",position:"insideBottom",offset:-18,fill:C.muted,fontSize:12}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"τ*",angle:-90,position:"insideLeft",fill:C.muted,fontSize:12}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`ε=10^(${v})`} valFmt={v=>v?.toFixed(0)}/>}/>
                        <Legend wrapperStyle={{fontSize:10,fontFamily:"monospace"}}/>
                        {sweepSArr.map((sv,i)=>(
                          <Line key={sv} type="monotone" dataKey={`tau_S${sv}`} name={`S=${sv}`}
                            stroke={MULTI_S_COLORS[i%4]} dot={{r:3}} strokeWidth={1.8} connectNulls={false}/>
                        ))}
                      </LineChart>
                    </ResponsiveContainer>
                  </div>

                  {/* Δ* vs ε */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:6,textAlign:"center"}}>
                      Minimal Δ* vs ε
                    </div>
                    <ResponsiveContainer width="100%" height={280}>
                      <LineChart data={sweepData} margin={{left:30,right:10,top:8,bottom:30}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="log10eps" stroke={C.muted}
                          tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"ε",position:"insideBottom",offset:-18,fill:C.muted,fontSize:12}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"Δ*",angle:-90,position:"insideLeft",fill:C.muted,fontSize:12}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`ε=10^(${v})`} valFmt={v=>v?.toFixed(0)}/>}/>
                        <Legend wrapperStyle={{fontSize:10,fontFamily:"monospace"}}/>
                        {sweepSArr.map((sv,i)=>(
                          <Line key={sv} type="monotone" dataKey={`delta_S${sv}`} name={`S=${sv}`}
                            stroke={MULTI_S_COLORS[i%4]} dot={{r:3}} strokeWidth={1.8} connectNulls={false}/>
                        ))}
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                </div>

                {/* Bottom row: combined plot — N_A(1/2)/N (dashed) + (K+Δ*)/N (solid) */}
                <div style={{borderTop:`1px solid ${C.border}`,paddingTop:16}}>
                  <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:6,textAlign:"center"}}>
                    Combined: N_A(1/2)/N <span style={{opacity:0.6}}>(dashed)</span> and (K+Δ*)/N <span style={{opacity:0.6}}>(solid)</span> vs ε
                    &nbsp;·&nbsp; red line = K/N = 1/r = {(K/N).toFixed(3)}
                  </div>
                  <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:10,opacity:0.7}}>
                    N_A(1/2)/N: min fraction where a single node detects recoverability with prob ≥ 1/2 &nbsp;·&nbsp;
                    (K+Δ*)/N: fraction above which recoverability is certified with prob ≥ 1−ε &nbsp;·&nbsp;
                    Grey zone = region between the two curves
                  </div>
                  <ResponsiveContainer width="100%" height={340}>
                    <LineChart data={sweepData} margin={{left:30,right:20,top:8,bottom:30}}>
                      <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                      <XAxis dataKey="log10eps" stroke={C.muted}
                        tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                        tickFormatter={v=>`10^${v.toFixed(0)}`}
                        label={{value:"ε",position:"insideBottom",offset:-18,fill:C.muted,fontSize:12}}/>
                      <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                        domain={[K/N - 0.01, 1.0]}
                        tickFormatter={v=>v.toFixed(2)}
                        label={{value:"N_A / N",angle:-90,position:"insideLeft",fill:C.muted,fontSize:11}}/>
                      <Tooltip content={<CustomTT labelFmt={v=>`ε=10^(${v})`} valFmt={v=>v?.toFixed(4)}/>}/>
                      {/* K/N reference line */}
                      <ReferenceLine y={K/N} stroke={C.red} strokeWidth={1.5}
                        label={{value:`K/N = ${(K/N).toFixed(3)}`,position:"insideRight",fill:C.red,fontSize:9}}/>
                      {/* N_A(1/2)/N — dashed lines */}
                      {sweepSArr.map((sv,i)=>(
                        <Line key={`uh_${sv}`} type="monotone" dataKey={`uhalf_S${sv}`}
                          name={`N_A(1/2)/N, S=${sv}`}
                          stroke={MULTI_S_COLORS[i%4]} dot={{r:3}} strokeWidth={1.8}
                          strokeDasharray="6 3" connectNulls={false}/>
                      ))}
                      {/* (K+Δ*)/N — solid lines */}
                      {sweepSArr.map((sv,i)=>(
                        <Line key={`kdn_${sv}`} type="monotone" dataKey={`kdnS${sv}`}
                          name={`(K+Δ*)/N, S=${sv}`}
                          stroke={MULTI_S_COLORS[i%4]} dot={{r:3}} strokeWidth={1.8}
                          connectNulls={false}/>
                      ))}
                    </LineChart>
                  </ResponsiveContainer>
                </div>
              </>
            )}

            {/* NETWORK BOUNDS */}
            {tab==="network" && (
              <>
                <SecHead>Network-level error bounds vs validator count n — multi-N_B</SecHead>
                <div style={{fontSize:11,color:C.muted,marginBottom:10}}>
                  ε={epsilon} &nbsp;·&nbsp; Two panels matching Python output.
                  &nbsp;<span style={{color:C.blue}}>Left</span>: P(maj. accepts valid block | data unrecover.) = 2ⁿ·ε^(N_B·⌈n/2⌉)
                  &nbsp;·&nbsp;<span style={{color:C.red}}>Right</span>: P(maj. rejects invalid block | data recover.) = 2ⁿ·[1−(1−ε)^N_B]^⌈n/2⌉
                </div>

                {/* ε validity warning */}
                {(() => {
                  const epsMax = 1 - Math.pow(3/4, 1/NB);
                  return epsilon >= epsMax ? (
                    <div style={{marginBottom:10,padding:"6px 12px",borderRadius:6,
                      background:"rgba(248,81,73,0.08)",border:`1px solid ${C.red}`,
                      fontSize:11,fontFamily:"monospace",color:C.red}}>
                      ⚠ ε={epsilon} ≥ 1−(3/4)^(1/N_B) ≈ {epsMax.toExponential(3)} for N_B={NB}.
                      Network bounds will NOT decrease with n — reduce ε or N_B.
                    </div>
                  ) : null;
                })()}

                <div style={{display:"flex",alignItems:"center",gap:12,marginBottom:10,flexWrap:"wrap"}}>
                  <Btn color={C.green} active={!!netSimData} onClick={runNetSim}>
                    {netSimRunning?"Running…":netSimData?"Re-run Simulation":"▶ Run Simulation"}
                  </Btn>
                  {netSimData&&<Btn color={C.red} active={false} onClick={()=>setNetSimData(null)}>✕ Clear</Btn>}
                  {netSimData&&<span style={{fontSize:11,color:C.green,fontFamily:"monospace"}}>✓ Squares = simulated P(majority wrong) — should sit at or below theory bound</span>}
                </div>
                {/* NB color legend */}
                <div style={{display:"flex",gap:18,marginBottom:14,flexWrap:"wrap",fontSize:11,fontFamily:"monospace",color:C.muted}}>
                  {NB_VALS.map((nb,i)=>(
                    <div key={nb} style={{display:"flex",alignItems:"center",gap:5}}>
                      <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={NB_COLORS[i]} strokeWidth={2}/></svg>
                      <span style={{color:NB_COLORS[i]}}>N_B = {nb}</span>
                    </div>
                  ))}
                </div>

                {/* Two panels side by side */}
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:16}}>

                  {/* Left: unrecoverable — Model B */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:6,textAlign:"center"}}>
                      P(block valid for maj. | data <span style={{color:C.red}}>unrecover.</span>) = 2ⁿ·ε^(N_B·⌈n/2⌉)
                    </div>
                    <ResponsiveContainer width="100%" height={360}>
                      <ComposedChart data={networkMerged} margin={{left:22,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="n" stroke={C.muted}
                          tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"n (validators)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:11}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"log₁₀(bound)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:10}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`n=${v}`} valFmt={v=>`10^(${v?.toFixed(1)})`}/>}/>
                        {NB_VALS.map((nb,i)=>(
                          <Line key={nb} type="monotone" dataKey={`unrec_${nb}`}
                            name={`N_B=${nb}`} stroke={NB_COLORS[i]} dot={false} strokeWidth={2} connectNulls={false}/>
                        ))}
                        {netSimData&&NB_VALS.map((nb,i)=>(
                          <Scatter key={`us_${nb}`} dataKey={`unrec_sim_${nb}`} name={`sim N_B=${nb}`} fill={NB_COLORS[i]}
                            shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={NB_COLORS[i]} opacity={0.85}/>}}/>
                        ))}
                        <Legend wrapperStyle={{fontSize:11,fontFamily:"monospace"}}/>
                      </ComposedChart>
                    </ResponsiveContainer>
                  </div>

                  {/* Right: recoverable — Model A */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:6,textAlign:"center"}}>
                      P(block invalid for maj. | data <span style={{color:C.green}}>recover.</span>) = 2ⁿ·[1−(1−ε)^N_B]^⌈n/2⌉
                    </div>
                    <ResponsiveContainer width="100%" height={360}>
                      <ComposedChart data={networkMerged} margin={{left:22,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="n" stroke={C.muted}
                          tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"n (validators)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:11}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"log₁₀(bound)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:10}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`n=${v}`} valFmt={v=>`10^(${v?.toFixed(1)})`}/>}/>
                        {NB_VALS.map((nb,i)=>(
                          <Line key={nb} type="monotone" dataKey={`rec_${nb}`}
                            name={`N_B=${nb}`} stroke={NB_COLORS[i]} dot={false} strokeWidth={2} connectNulls={false}/>
                        ))}
                        {netSimData&&NB_VALS.map((nb,i)=>(
                          <Scatter key={`rs_${nb}`} dataKey={`rec_sim_${nb}`} name={`sim N_B=${nb}`} fill={NB_COLORS[i]}
                            shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={NB_COLORS[i]} opacity={0.85}/>}}/>
                        ))}
                        <Legend wrapperStyle={{fontSize:11,fontFamily:"monospace"}}/>
                      </ComposedChart>
                    </ResponsiveContainer>
                  </div>
                </div>

                {/* p-value table matching Python's print output (fixed: ε=1e-4, not 1e-5) */}
                <div style={{marginTop:16,padding:"10px 14px",background:C.bg,borderRadius:7,
                  border:`1px solid ${C.border}`,fontFamily:"monospace",fontSize:11,color:C.muted}}>
                  <div style={{color:C.text,marginBottom:6,fontWeight:700}}>
                    Model B: p = ε^N_B with ε={epsilon}
                  </div>
                  {NB_VALS.map(nb=>{
                    const log10p = nb * Math.log10(epsilon);
                    return (
                      <div key={nb} style={{marginBottom:2}}>
                        N_B={String(nb).padStart(4,' ')}:&nbsp;
                        log₁₀(p) = <span style={{color:C.blue}}>{log10p.toFixed(0)}</span>
                        &nbsp; (p = 10^{log10p.toFixed(0)})
                      </div>
                    );
                  })}
                  <div style={{marginTop:6,color:C.yellow,fontSize:10}}>
                    ✓ Note: ε={epsilon} used throughout (Python script had a typo printing "1e-5" while computing with 1e-4).
                  </div>
                </div>
              </>
            )}

            {/* WASTED SLOTS */}
            {tab==="wasted" && (
              <>
                <SecHead>Average wasted slots per epoch vs n — three regimes</SecHead>
                <div style={{fontSize:11,color:C.muted,marginBottom:10}}>
                  ε={epsilon}, N_B={NB}, T={T_epoch.toLocaleString()}, f≈{f.toFixed(4)}
                  &nbsp;·&nbsp; Tf = {Math.round(T_epoch*f).toLocaleString()} avg non-empty slots/epoch
                </div>
                {/* 3-curve legend */}
                <div style={{display:"flex",gap:18,marginBottom:10,flexWrap:"wrap",fontSize:11,fontFamily:"monospace",color:C.muted}}>
                  <div style={{display:"flex",alignItems:"center",gap:5}}>
                    <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={C.red} strokeWidth={2}/></svg>
                    <span>Code 2 — Basic: T·f·2ⁿ·(1−(1−ε)^N_B)^⌈n/2⌉</span>
                  </div>
                  <div style={{display:"flex",alignItems:"center",gap:5}}>
                    <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={C.blue} strokeWidth={2} strokeDasharray="5 2"/></svg>
                    <span>Code 3 — Tight upper: T·f·(4p(1−p))^(n/2), p_tight={p_tight} &lt; 0.5</span>
                  </div>
                  <div style={{display:"flex",alignItems:"center",gap:5}}>
                    <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={C.green} strokeWidth={2} strokeDasharray="3 2"/></svg>
                    <span>Code 4 — Lower bound: T·f·(1−exp(−n·D(q‖p))), p_inv={p_inv} &gt; 0.5</span>
                  </div>
                </div>
                {p_tight>=0.5 && (
                  <div style={{marginBottom:8,padding:"5px 10px",borderRadius:5,background:"rgba(248,81,73,0.08)",border:`1px solid ${C.red}`,fontSize:11,fontFamily:"monospace",color:C.red}}>
                    ⚠ p_tight={p_tight} ≥ 0.5 — Code 3 tight bound requires p &lt; 0.5. Use Auto p_tight button.
                  </div>
                )}
                {p_inv<=0.5 && (
                  <div style={{marginBottom:8,padding:"5px 10px",borderRadius:5,background:"rgba(248,81,73,0.08)",border:`1px solid ${C.red}`,fontSize:11,fontFamily:"monospace",color:C.red}}>
                    ⚠ p_inv={p_inv} ≤ 0.5 — Code 4 lower bound requires p &gt; 0.5.
                  </div>
                )}
                <div style={{display:"flex",alignItems:"center",gap:12,marginBottom:10,flexWrap:"wrap"}}>
                  <Btn color={C.green} active={!!wastedSimData} onClick={runWastedSim}>
                    {wastedSimRunning?"Running…":wastedSimData?"Re-run Simulation":"▶ Run Simulation"}
                  </Btn>
                  {wastedSimData&&<Btn color={C.red} active={false} onClick={()=>setWastedSimData(null)}>✕ Clear</Btn>}
                  {wastedSimData&&<span style={{fontSize:11,color:C.green,fontFamily:"monospace"}}>✓ Squares = simulated wasted slots — should sit at or below Code2/3 bounds, at or above Code4</span>}
                </div>
                <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:6,opacity:0.8}}>
                  Log₁₀ scale. Simulation uses Bernoulli(p) majority vote × T·f for each code.
                </div>
                <ResponsiveContainer width="100%" height={420}>
                  <ComposedChart data={wastedMerged} margin={{left:34,right:20,top:10,bottom:22}}>
                    <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                    <XAxis dataKey="n" stroke={C.muted}
                      tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                      label={{value:"n (validators)",position:"insideBottom",offset:-10,fill:C.muted,fontSize:12}}/>
                    <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                      tickFormatter={v=>`10^${v.toFixed(0)}`}
                      label={{value:"log₁₀(wasted slots/epoch)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:9}}/>
                    <Tooltip content={<CustomTT labelFmt={v=>`n=${v}`} valFmt={v=>`10^(${v?.toFixed(2)})`}/>}/>
                    <Legend wrapperStyle={{fontSize:11,fontFamily:"monospace"}}/>
                    <ReferenceLine y={Math.log10(T_epoch*f)} stroke={C.yellow} strokeDasharray="5 3"
                      label={{value:`Tf=${Math.round(T_epoch*f).toLocaleString()}`,position:"insideRight",fill:C.yellow,fontSize:10}}/>
                    <Line type="monotone" dataKey="log10_wasted" name="Code 2 — Basic upper"
                      stroke={C.red} dot={false} strokeWidth={2} connectNulls={false}/>
                    <Line type="monotone" dataKey="log10_tight" name={`Code 3 — Tight upper (p=${p_tight})`}
                      stroke={C.blue} dot={false} strokeWidth={2} strokeDasharray="5 2" connectNulls={false}/>
                    <Line type="monotone" dataKey="log10_lower" name={`Code 4 — Lower bound (p=${p_inv})`}
                      stroke={C.green} dot={false} strokeWidth={2} strokeDasharray="3 2" connectNulls={false}/>
                    {wastedSimData&&<Scatter dataKey="log10_wasted_sim" name="Code 2 sim" fill={C.red}   shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.red}   opacity={0.85}/>}}/>}
                    {wastedSimData&&<Scatter dataKey="log10_tight_sim"  name="Code 3 sim" fill={C.blue}  shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.blue}  opacity={0.85}/>}}/>}
                    {wastedSimData&&<Scatter dataKey="log10_lower_sim"  name="Code 4 sim" fill={C.green} shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.green} opacity={0.85}/>}}/>}
                  </ComposedChart>
                </ResponsiveContainer>
                <div style={{marginTop:10,padding:"8px 12px",background:C.bg,borderRadius:7,
                  border:`1px solid ${C.border}`,fontFamily:"monospace",fontSize:10,color:C.muted}}>
                  <span style={{color:C.yellow}}>Code 3 p_tight</span>: Python hardcodes p = (1−(1−ε)^N) + 0.1. Use "Auto p_tight" button to match this exactly (p = {parseFloat(Math.min(0.499,(1-Math.pow(1-epsilon,NB))+0.1).toFixed(4))}).
                  &nbsp;The +0.1 offset moves p away from the (1−(1−ε)^N_B) boundary.
                  &nbsp;<span style={{color:C.yellow}}>Code 4 p_inv</span>: Python hardcodes p = 0.7. Adjust p_inv parameter to match your scenario.
                </div>
              </>
            )}

            {/* CHERNOFF BOUND — two separate panels matching Python's two plt.scatter() calls */}
            {tab==="chernoff" && (
              <>
                <SecHead>Chernoff bounds — P(majority accepts bad block), both regimes</SecHead>
                {(p_tight>=0.5 || p_inv<=0.5) && (
                  <div style={{marginBottom:10,padding:"5px 10px",borderRadius:5,
                    background:"rgba(210,153,34,0.08)",border:`1px solid ${C.yellow}`,
                    fontSize:11,fontFamily:"monospace",color:C.yellow}}>
                    ⚠ {p_tight>=0.5?`p_tight=${p_tight} must be < 0.5 for Code 3. `:""}{p_inv<=0.5?`p_inv=${p_inv} must be > 0.5 for Code 4.`:""}
                  </div>
                )}
                <div style={{display:"flex",alignItems:"center",gap:12,marginBottom:12,flexWrap:"wrap"}}>
                  <Btn color={C.green} active={!!chernSimData} onClick={runChernSim}>
                    {chernSimRunning?"Running…":chernSimData?"Re-run Simulation":"▶ Run Simulation"}
                  </Btn>
                  {chernSimData&&<Btn color={C.red} active={false} onClick={()=>setChernSimData(null)}>✕ Clear</Btn>}
                  {chernSimData&&<span style={{fontSize:11,color:C.green,fontFamily:"monospace"}}>✓ Teal/orange squares = exact simulated P(maj. wrong) — below Code3 bound (left), above Code4 bound (right)</span>}
                </div>
                {/* Two panels — each matches one Python plt.scatter() call */}
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:16}}>

                  {/* Left — Code 3: tight upper bound (p < 0.5, grey zone above red line) */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:4,textAlign:"center"}}>
                      <span style={{color:C.blue}}>Code 3</span> — Tight <span style={{color:C.blue}}>upper</span> bound (p_tight={p_tight} &lt; 0.5)
                    </div>
                    <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:8,textAlign:"center",opacity:0.7}}>
                      P(maj. accepts) ≤ (4p(1−p))^(n/2) &nbsp;·&nbsp; log₁₀ scale &nbsp;·&nbsp; grey zone
                    </div>
                    <ResponsiveContainer width="100%" height={340}>
                      <ComposedChart data={chernMerged} margin={{left:22,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="n" stroke={C.muted}
                          tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"n (validators)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:11}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"log₁₀(upper bound)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:10}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`n=${v}`} valFmt={v=>`10^(${v?.toFixed(2)})`}/>}/>
                        <Line type="monotone" dataKey="log10_tight" name={`Code 3 bound (p=${p_tight})`}
                          stroke={C.blue} dot={false} strokeWidth={2} connectNulls={false}/>
                        {chernSimData&&<Scatter dataKey="sim_tight" name="Exact sim" fill={C.teal}
                          shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.teal} opacity={0.9}/>}}/>}
                      </ComposedChart>
                    </ResponsiveContainer>
                  </div>

                  {/* Right — Code 4: lower bound (p > 0.5, below red line) */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:4,textAlign:"center"}}>
                      <span style={{color:C.red}}>Code 4</span> — Chernoff <span style={{color:C.red}}>lower</span> bound (p_inv={p_inv} &gt; 0.5)
                    </div>
                    <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:8,textAlign:"center",opacity:0.7}}>
                      P(maj. accepts) ≥ 1−exp(−n·KL(q‖p)) &nbsp;·&nbsp; linear scale &nbsp;·&nbsp; below red line
                    </div>
                    <ResponsiveContainer width="100%" height={340}>
                      <ComposedChart data={chernMerged} margin={{left:20,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="n" stroke={C.muted}
                          tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"n (validators)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:11}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                          domain={[0,1]} tickFormatter={v=>v.toFixed(2)}
                          label={{value:"P(majority accepts bad block)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:9}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`n=${v}`} valFmt={v=>v?.toFixed(5)}/>}/>
                        <ReferenceLine y={0.5} stroke={C.yellow} strokeDasharray="5 3"
                          label={{value:"0.5",position:"insideRight",fill:C.yellow,fontSize:10}}/>
                        <Line type="monotone" dataKey="lower_bound" name={`Code 4 bound (p=${p_inv})`}
                          stroke={C.red} dot={false} strokeWidth={2} connectNulls={false}/>
                        {chernSimData&&<Scatter dataKey="sim_lower" name="Exact sim" fill={C.orange}
                          shape={p=>{const{cx,cy}=p;if(!cx||!cy)return null;return<rect x={cx-4} y={cy-4} width={8} height={8} fill={C.orange} opacity={0.9}/>}}/>}
                      </ComposedChart>
                    </ResponsiveContainer>
                  </div>
                </div>

                {/* Formula notes */}
                <div style={{marginTop:12,padding:"8px 12px",background:C.bg,borderRadius:7,
                  border:`1px solid ${C.border}`,fontFamily:"monospace",fontSize:10,color:C.muted}}>
                  <div style={{marginBottom:3}}>
                    <span style={{color:C.blue}}>Code 3</span>: (4p(1−p))^(n/2) = exp(−n·KL(1/2‖p)) — tight Chernoff upper bound for grey zone (p &lt; 0.5).
                    Python: p = (1−(1−ε)^N)+0.1 ≈ {parseFloat(Math.min(0.499,(1-Math.pow(1-epsilon,NB))+0.1).toFixed(4))} for current ε,NB. Use "Auto p_tight" to match.
                  </div>
                  <div>
                    <span style={{color:C.red}}>Code 4</span>: 1−exp(−n·KL(q‖p)), q=(⌈n/2⌉−1)/n — Chernoff lower bound below red line (p &gt; 0.5). Python: p=0.7. Set p_inv accordingly.
                  </div>
                  <div style={{marginTop:4,color:C.yellow}}>
                    ✓ Split into two panels to match Python's two separate plt.scatter() calls. Code 3 on log scale (values decay to ~10⁻⁸ at n=100). Code 4 on linear scale (grows toward 1).
                  </div>
                </div>
              </>
            )}

            {/* BLOCKCHAIN — Probability + Median Time (matches Python Code 1 two panels) */}
            {tab==="median" && (
              <>
                <SecHead>Blockchain analysis — probability of invalid block adoption &amp; median time</SecHead>
                <div style={{fontSize:11,color:C.muted,marginBottom:14}}>
                  ε={epsilon}, f≈{f.toFixed(4)} &nbsp;·&nbsp; SPY=31,536,000 (365 days, matching Python) &nbsp;·&nbsp; NB=1 (single-blob blockchain view)
                </div>
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:16}}>

                  {/* Left: y1 = f·2^n·ε^⌈n/2⌉  — prob. invalid block accepted by majority */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:6,textAlign:"center"}}>
                      P(invalid block accepted by maj.) = f·2ⁿ·ε^⌈n/2⌉ &nbsp;·&nbsp; log₁₀ scale
                    </div>
                    <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:8,opacity:0.7,textAlign:"center"}}>
                      y1 = f·2ⁿ·ε^⌈n/2⌉ — slot probability × network acceptance bound
                    </div>
                    <ResponsiveContainer width="100%" height={340}>
                      <LineChart data={blockchainData} margin={{left:22,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="n" stroke={C.muted}
                          tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"n (validators)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:11}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"log₁₀(prob.)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:10}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`n=${v}`} valFmt={v=>`10^(${v?.toFixed(1)})`}/>}/>
                        <Line type="monotone" dataKey="log10_y1" name="P(invalid accepted)"
                          stroke={C.red} dot={false} strokeWidth={2} connectNulls={false}/>
                      </LineChart>
                    </ResponsiveContainer>
                  </div>

                  {/* Right: y2 = ⌈ln(2)·(2^(−n)·ε^(−⌈n/2⌉) − f)/f⌉/SPY — median time (corrected formula) */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:6,textAlign:"center"}}>
                      Median time T₁/₂ to first invalid block (years) &nbsp;·&nbsp; log₁₀ scale
                    </div>
                    <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:8,opacity:0.7,textAlign:"center"}}>
                      y2 = ⌈ln(2)·(2^(−n)·ε^(−⌈n/2⌉) − f)/f⌉ / SPY &nbsp;·&nbsp; corrected from previous (−f term added)
                    </div>
                    <ResponsiveContainer width="100%" height={340}>
                      <LineChart data={blockchainData} margin={{left:22,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="n" stroke={C.muted}
                          tick={{fontSize:11,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"n (validators)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:11}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"log₁₀(years)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:10}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`n=${v}`} valFmt={v=>`10^(${v?.toFixed(1)}) yrs`}/>}/>
                        <ReferenceLine y={Math.log10(26.7e9)} stroke={C.yellow} strokeDasharray="5 3"
                          label={{value:"Age of Universe",position:"insideRight",fill:C.yellow,fontSize:10}}/>
                        <Line type="monotone" dataKey="log10_y2" name="Median time T₁/₂"
                          stroke={C.blue} dot={false} strokeWidth={2} connectNulls={false}/>
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                </div>

                {/* Formula note */}
                <div style={{marginTop:14,padding:"10px 14px",background:C.bg,borderRadius:7,
                  border:`1px solid ${C.border}`,fontFamily:"monospace",fontSize:11,color:C.muted}}>
                  <div style={{color:C.text,marginBottom:5,fontWeight:700}}>Formula notes (matching Python Code 1)</div>
                  <div style={{marginBottom:3}}>
                    y1 = f · 2ⁿ · ε^⌈n/2⌉ &nbsp;·&nbsp; upper bound on prob. invalid block adopted per slot
                  </div>
                  <div style={{marginBottom:3}}>
                    y2 = ⌈ ln(2) · (2^(−n) · ε^(−⌈n/2⌉) − f) / f ⌉ / SPY &nbsp;·&nbsp;
                    <span style={{color:C.green}}>corrected</span> vs. previous version which used ln(2)·2^(−n)·ε^(−⌈n/2⌉)/f/SPY (missing −f)
                  </div>
                  <div style={{color:C.yellow,marginTop:4,fontSize:10}}>
                    SPY = 31,536,000 s (365 days exactly, matching Python). Previous version used 365.25 days — negligible but now consistent.
                  </div>
                </div>
              </>
            )}

            {/* ════ BLOCK BUILDER ════ */}
            {tab==="builder" && (
              <>
                <SecHead>Block builder — hitting time τ&#8336;&#8320;&#8346;&#8329;&#8342;&#8329;: blobs to inspect before N_B are accepted</SecHead>
                <div style={{fontSize:11,color:C.muted,marginBottom:12}}>
                  τ&#8336;&#8320;&#8346;&#8329;&#8342;&#8329; = min&#123;T : P(τ&#8336;&#8320;&#8346; ≤ T) ≥ q&#125; &nbsp;·&nbsp; Approx: τ ≈ (N_B + z_q·√N_B) / p
                  &nbsp;·&nbsp; z&#8320;&#8329;&#8329;=2.3263, z&#8320;&#8329;&#8329;&#8329;=3.0902
                </div>

                {/* Controls row: q selector + simulation */}
                <div style={{display:"flex",alignItems:"center",gap:14,marginBottom:14,flexWrap:"wrap"}}>
                  <span style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>Confidence q:</span>
                  {[0.90,0.95,0.99,0.999].map(q=>(
                    <button key={q} onClick={()=>setQ_conf(q)} style={{
                      background:q_conf===q?C.blue:"transparent", color:q_conf===q?"#000":C.blue,
                      border:`1px solid ${C.blue}`, borderRadius:5,
                      padding:"4px 12px", cursor:"pointer", fontSize:11, fontFamily:"monospace",
                      fontWeight:q_conf===q?700:400,
                    }}>{q}</button>
                  ))}
                  <span style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>
                    z_q = {zQuantile(q_conf).toFixed(4)}
                  </span>
                  <div style={{height:18,width:1,background:C.border}}/>
                  <label style={{fontSize:11,color:C.muted,fontFamily:"monospace"}}>Trials:</label>
                  <input type="number" value={bSimTrials} min={20} max={2000} step={20}
                    onChange={e=>setBSimTrials(Math.max(20,parseInt(e.target.value)||100))}
                    style={{background:C.bg,border:`1px solid ${C.border}`,borderRadius:5,
                      color:C.text,fontFamily:"monospace",fontSize:12,padding:"3px 7px",width:72,outline:"none"}}/>
                  <Btn color={C.green} active={!!builderSimData} onClick={runBuilderSim}>
                    {bSimRunning ? "Running…" : builderSimData ? "Re-run Simulation" : "▶ Run Simulation"}
                  </Btn>
                  {builderSimData && (
                    <Btn color={C.red} active={false} onClick={()=>setBuilderSimData(null)}>✕ Clear</Btn>
                  )}
                </div>
                {builderSimData && (
                  <div style={{marginBottom:10,padding:"5px 12px",borderRadius:5,
                    background:"rgba(63,185,80,0.08)",border:`1px solid ${C.green}`,
                    fontSize:11,fontFamily:"monospace",color:C.green}}>
                    ✓ Simulation complete ({bSimTrials} trials/point) — scatter points overlay theory lines.
                    &nbsp;<span style={{color:C.yellow}}>Unrecoverable panel: simulation shown only for ε=10⁻¹ (larger ε too slow in browser).</span>
                  </div>
                )}

                {/* Two panels side by side: Unrecoverable | Recoverable */}
                <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:16,marginBottom:20}}>

                  {/* LEFT — Unrecoverable: p = ε, log₁₀ scale */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:5,textAlign:"center"}}>
                      <span style={{color:C.red}}>Unrecoverable</span> (p = ε) — τ&#8336;&#8320;&#8346;&#8329; vs N_B &nbsp;·&nbsp; log₁₀ scale
                    </div>
                    <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:8,opacity:0.7,textAlign:"center"}}>
                      data is unrecoverable → P(n_A≥τ|N_A) ≤ ε → each blob accepted w/ prob p=ε
                    </div>
                    {/* Legend */}
                    <div style={{display:"flex",gap:12,marginBottom:8,flexWrap:"wrap",justifyContent:"center",fontSize:10,fontFamily:"monospace",color:C.muted}}>
                      {EPS_VALS.map((eps,ki)=>(
                        <div key={ki} style={{display:"flex",alignItems:"center",gap:4}}>
                          <svg width={22} height={8}><line x1={0} y1={4} x2={22} y2={4} stroke={EPS_COLS[ki]} strokeWidth={2}/></svg>
                          <span style={{color:EPS_COLS[ki]}}>ε={EPS_LBLS[ki]}</span>
                        </div>
                      ))}
                    </div>
                    <ResponsiveContainer width="100%" height={340}>
                      <ComposedChart data={builderMerged} margin={{left:22,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="NB" stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"N_B (blobs per block)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:10}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>`10^${v.toFixed(0)}`}
                          label={{value:"log₁₀(τ_NB,q)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:10}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`N_B=${v}`} valFmt={v=>`10^(${v?.toFixed(2)})`}/>}/>
                        {EPS_VALS.map((_,ki)=>(
                          <Line key={`ul_${ki}`} type="monotone" dataKey={`u_log10_${ki}`}
                            name={`ε=${EPS_LBLS[ki]}`} stroke={EPS_COLS[ki]}
                            dot={false} strokeWidth={2} connectNulls={false}/>
                        ))}
                        {/* Simulation scatter — only ε=10⁻¹ (ki=0) is feasible */}
                        {builderSimData && (
                          <Scatter dataKey="u_sim_log10_0" name={`sim ε=${EPS_LBLS[0]}`}
                            fill={EPS_COLS[0]}
                            shape={(props)=>{
                              const {cx,cy}=props;
                              if(cx==null||cy==null) return null;
                              return <rect x={cx-4} y={cy-4} width={8} height={8} fill={EPS_COLS[0]} opacity={0.9}/>;
                            }}/>
                        )}
                        <Legend wrapperStyle={{fontSize:10,fontFamily:"monospace"}}/>
                      </ComposedChart>
                    </ResponsiveContainer>
                    <div style={{marginTop:6,padding:"5px 10px",background:C.bg,borderRadius:5,
                      border:`1px solid ${C.border}`,fontSize:10,fontFamily:"monospace",color:C.muted}}>
                      τ ≈ N_B/ε + z_q·√N_B/ε &nbsp;·&nbsp; dominant term N_B/ε grows linearly in N_B &nbsp;·&nbsp;
                      <span style={{color:C.yellow}}>top curve = ε=10⁻⁴</span>
                    </div>
                  </div>

                  {/* RIGHT — Recoverable: p = 1−ε, linear scale */}
                  <div>
                    <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:5,textAlign:"center"}}>
                      <span style={{color:C.green}}>Recoverable</span> (p = 1−ε) — τ&#8336;&#8320;&#8346;&#8329; vs N_B &nbsp;·&nbsp; linear scale
                    </div>
                    <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:8,opacity:0.7,textAlign:"center"}}>
                      data is recoverable → P(n_A≥τ|N_A) ≥ 1−ε → each blob accepted w/ prob p=1−ε
                    </div>
                    {/* Legend */}
                    <div style={{display:"flex",gap:12,marginBottom:8,flexWrap:"wrap",justifyContent:"center",fontSize:10,fontFamily:"monospace",color:C.muted}}>
                      {EPS_VALS.map((eps,ki)=>(
                        <div key={ki} style={{display:"flex",alignItems:"center",gap:4}}>
                          <svg width={22} height={8}><line x1={0} y1={4} x2={22} y2={4} stroke={EPS_COLS[ki]} strokeWidth={2}/></svg>
                          <span style={{color:EPS_COLS[ki]}}>p=1−{EPS_LBLS[ki]}</span>
                        </div>
                      ))}
                      <div style={{display:"flex",alignItems:"center",gap:4}}>
                        <svg width={22} height={8}><line x1={0} y1={4} x2={22} y2={4} stroke={C.muted} strokeWidth={1.5} strokeDasharray="4 2"/></svg>
                        <span>τ=N_B (lower bound)</span>
                      </div>
                    </div>
                    <ResponsiveContainer width="100%" height={340}>
                      <ComposedChart data={builderMerged} margin={{left:30,right:10,top:8,bottom:28}}>
                        <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                        <XAxis dataKey="NB" stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          label={{value:"N_B (blobs per block)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:10}}/>
                        <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                          tickFormatter={v=>v>=1000?`${(v/1000).toFixed(1)}k`:v.toFixed(0)}
                          label={{value:"τ_{N_B,q} (blobs to inspect)",angle:-90,position:"insideLeft",fill:C.muted,fontSize:9}}/>
                        <Tooltip content={<CustomTT labelFmt={v=>`N_B=${v}`} valFmt={v=>v?.toFixed(0)}/>}/>
                        <Line type="monotone" dataKey="NB"
                          name="τ = N_B (ideal)" stroke={C.muted} dot={false} strokeWidth={1.5}
                          strokeDasharray="4 2" connectNulls={false}/>
                        {EPS_VALS.map((_,ki)=>(
                          <Line key={`rl_${ki}`} type="monotone" dataKey={`r_approx_${ki}`}
                            name={`p=1-${EPS_LBLS[ki]}`} stroke={EPS_COLS[ki]}
                            dot={false} strokeWidth={2} connectNulls={false}/>
                        ))}
                        {/* Simulation scatter — all ε values feasible since p≈1 */}
                        {builderSimData && EPS_VALS.map((_,ki)=>(
                          <Scatter key={`rs_${ki}`} dataKey={`r_sim_${ki}`}
                            name={`sim p=1-${EPS_LBLS[ki]}`} fill={EPS_COLS[ki]}
                            shape={(props)=>{
                              const {cx,cy}=props;
                              if(cx==null||cy==null) return null;
                              return <rect x={cx-4} y={cy-4} width={8} height={8} fill={EPS_COLS[ki]} opacity={0.85}/>;
                            }}/>
                        ))}
                        <Legend wrapperStyle={{fontSize:10,fontFamily:"monospace"}}/>
                      </ComposedChart>
                    </ResponsiveContainer>
                    <div style={{marginTop:6,padding:"5px 10px",background:C.bg,borderRadius:5,
                      border:`1px solid ${C.border}`,fontSize:10,fontFamily:"monospace",color:C.muted}}>
                      τ ≈ N_B/(1−ε) + z_q·√N_B/(1−ε) ≈ N_B + z_q·√N_B for small ε &nbsp;·&nbsp;
                      <span style={{color:C.green}}>all curves converge near τ = N_B</span>
                    </div>
                  </div>
                </div>

                {/* Grey zone — full width */}
                <div style={{borderTop:`1px solid ${C.border}`,paddingTop:16}}>
                  <div style={{fontSize:11,color:C.muted,fontFamily:"monospace",marginBottom:5,textAlign:"center"}}>
                    <span style={{color:C.purple}}>Grey zone</span> (K+1 ≤ N_A &lt; K+Δ) — fixed p ∈ &#123;0.2, 0.3, 0.5, 0.7&#125; &nbsp;·&nbsp; log₁₀ scale
                  </div>
                  <div style={{fontSize:10,color:C.muted,fontFamily:"monospace",marginBottom:10,opacity:0.7,textAlign:"center"}}>
                    P(n_A ≥ τ | N_A) ∈ (ε, 1−ε) &nbsp;·&nbsp; τ&#8336;&#8320;&#8346;&#8329;(1−ε) &lt; τ&#8336;&#8320;&#8346;&#8329;(p) &lt; τ&#8336;&#8320;&#8346;&#8329;(ε)
                  </div>
                  {/* Legend */}
                  <div style={{display:"flex",gap:16,marginBottom:10,flexWrap:"wrap",justifyContent:"center",fontSize:11,fontFamily:"monospace",color:C.muted}}>
                    {PGREY_VALS.map((p,pi)=>(
                      <div key={pi} style={{display:"flex",alignItems:"center",gap:5}}>
                        <svg width={26} height={10}><line x1={0} y1={5} x2={26} y2={5} stroke={PGREY_COLS[pi]} strokeWidth={2}/></svg>
                        <span style={{color:PGREY_COLS[pi]}}>p = {p}</span>
                      </div>
                    ))}
                  </div>
                  <ResponsiveContainer width="100%" height={320}>
                    <ComposedChart data={builderMerged} margin={{left:22,right:20,top:8,bottom:28}}>
                      <CartesianGrid strokeDasharray="3 3" stroke={C.border}/>
                      <XAxis dataKey="NB" stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                        label={{value:"N_B (blobs per block)",position:"insideBottom",offset:-14,fill:C.muted,fontSize:10}}/>
                      <YAxis stroke={C.muted} tick={{fontSize:10,fill:C.muted,fontFamily:"monospace"}}
                        tickFormatter={v=>`10^${v.toFixed(0)}`}
                        label={{value:"log₁₀(τ_{N_B,q})",angle:-90,position:"insideLeft",fill:C.muted,fontSize:10}}/>
                      <Tooltip content={<CustomTT labelFmt={v=>`N_B=${v}`} valFmt={v=>`10^(${v?.toFixed(2)})`}/>}/>
                      <Legend wrapperStyle={{fontSize:11,fontFamily:"monospace"}}/>
                      {/* Theory lines */}
                      {PGREY_VALS.map((_,pi)=>(
                        <Line key={`gl_${pi}`} type="monotone" dataKey={`g_log10_${pi}`}
                          name={`p=${PGREY_VALS[pi]}`} stroke={PGREY_COLS[pi]}
                          dot={false} strokeWidth={2} connectNulls={false}/>
                      ))}
                      {/* Simulation scatter — all p values feasible (p ≥ 0.2) */}
                      {builderSimData && PGREY_VALS.map((_,pi)=>(
                        <Scatter key={`gs_${pi}`} dataKey={`g_sim_log10_${pi}`}
                          name={`sim p=${PGREY_VALS[pi]}`} fill={PGREY_COLS[pi]}
                          shape={(props)=>{
                            const {cx,cy}=props;
                            if(cx==null||cy==null) return null;
                            return <rect x={cx-4} y={cy-4} width={8} height={8} fill={PGREY_COLS[pi]} opacity={0.9}/>;
                          }}/>
                      ))}
                    </ComposedChart>
                  </ResponsiveContainer>
                </div>

                {/* Formula reference box */}
                <div style={{marginTop:16,padding:"12px 16px",background:C.bg,borderRadius:8,
                  border:`1px solid ${C.border}`,fontFamily:"monospace",fontSize:11,color:C.muted}}>
                  <div style={{color:C.text,marginBottom:8,fontWeight:700}}>Negative-binomial hitting time τ_NB,q</div>
                  <div style={{marginBottom:5}}>
                    <span style={{color:C.blue}}>PMF:</span>
                    &nbsp;P(τ&#8336;&#8320;&#8346;=t) = C(t−1, N_B−1) · p^N_B · (1−p)^(t−N_B), t = N_B, N_B+1, …
                  </div>
                  <div style={{marginBottom:5}}>
                    <span style={{color:C.green}}>q-quantile:</span>
                    &nbsp;τ&#8336;&#8320;&#8346;&#8329; = min&#123;T ≥ N_B : Σ P(τ&#8336;&#8320;&#8346;=t) ≥ q&#125;
                  </div>
                  <div style={{marginBottom:5}}>
                    <span style={{color:C.yellow}}>Approximation:</span>
                    &nbsp;τ&#8336;&#8320;&#8346;&#8329; ≈ (N_B + z_q·√N_B) / p &nbsp;(accurate for N_B ≥ 10)
                  </div>
                  <div style={{marginBottom:5}}>
                    <span style={{color:C.purple}}>z_q values:</span>
                    &nbsp;z&#8320;&#8329;&#8320;=1.2816, z&#8320;&#8329;&#8325;=1.6449, z&#8320;&#8329;&#8329;=2.3263, z&#8320;&#8329;&#8329;&#8329;=3.0902
                  </div>
                  <div style={{marginTop:8,padding:"6px 10px",background:C.panel,borderRadius:5,
                    border:`1px solid ${C.border}`,fontSize:10,color:C.muted}}>
                    <span style={{color:C.blue}}>Interpretation:</span>
                    &nbsp;τ&#8336;&#8320;&#8346;&#8329; is the number of blobs the builder must inspect to fill a block with
                    N_B accepted blobs, with confidence q. For unrecoverable data (p=ε), τ ≈ N_B/ε — the builder
                    wastes ≈1/ε attempts per accepted blob. For recoverable data (p≈1), τ ≈ N_B — almost no waste.
                    Current ε={epsilon}: τ ≈ N_B/ε = {(1/epsilon).toFixed(0)}·N_B (unrecoverable),
                    τ ≈ N_B (recoverable).
                  </div>
                </div>
              </>
            )}

          </div>

          <div style={{marginTop:14,fontSize:10,color:C.muted,fontFamily:"monospace",textAlign:"center",opacity:0.45}}>
            DA SAMPLING ANALYSIS · HYPERGEOMETRIC MODEL · N={N} COLUMNS · K+1 RECOVERY THRESHOLD
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<DACalculator />);
  </script>
</body>
</html>
